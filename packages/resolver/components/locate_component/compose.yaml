compose:
  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value: $.options
    out:
      options: options
  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value: $.options.paths
    out:
      pathOptions: pathOptions
  - call: lcod://tooling/value/default_object@0.1.0
    in:
      value: $.options.cache
    out:
      cacheOptions: cacheOptions
  - call: lcod://tooling/value/default_array@0.1.0
    in:
      value: $.options.registrySources
    out:
      extraRegistrySources: extraRegistrySources
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const path = await import('node:path');
          const os = await import('node:os');
          const fs = await import('node:fs/promises');
          const cwd = process.cwd();

          const resolveString = (value) => (typeof value === 'string' && value.length ? value : null);

          const refererPath = resolveString(state.refererPath);
          const projectPathInput = resolveString(state.projectPath)
            || (refererPath ? path.dirname(path.resolve(cwd, refererPath)) : cwd);
          const projectRoot = path.resolve(cwd, projectPathInput);

          const projectCacheInput = resolveString(state.projectCacheDir)
            || path.join(projectRoot, '.lcod', 'cache');
          const homeDir = os.homedir() || projectRoot;
          const userCacheInput = resolveString(state.userCacheDir)
            || path.join(homeDir, '.lcod', 'cache');

          const catalogueCandidates = [];
          const explicitCatalogue = resolveString(state.cataloguePath);
          if (explicitCatalogue) catalogueCandidates.push(explicitCatalogue);
          const envCatalogue = resolveString(process.env.LCOD_REGISTRY_CATALOGUE);
          if (envCatalogue) catalogueCandidates.push(envCatalogue);
          const envRegistryRoot = resolveString(process.env.LCOD_REGISTRY_PATH);
          if (envRegistryRoot) catalogueCandidates.push(path.join(envRegistryRoot, 'catalogues.jsonl'));
          catalogueCandidates.push(path.join(projectRoot, 'catalogues.jsonl'));
          catalogueCandidates.push(path.join(projectRoot, '..', 'lcod-registry', 'catalogues.jsonl'));
          catalogueCandidates.push(path.join(projectRoot, '..', '..', 'lcod-registry', 'catalogues.jsonl'));
          if (envRegistryRoot) catalogueCandidates.push(path.join(envRegistryRoot, 'catalogues.json'));
          catalogueCandidates.push(path.join(projectRoot, 'catalogues.json'));
          catalogueCandidates.push(path.join(projectRoot, '..', 'lcod-registry', 'catalogues.json'));
          catalogueCandidates.push(path.join(projectRoot, '..', '..', 'lcod-registry', 'catalogues.json'));

          let cataloguePath = null;
          for (const candidate of catalogueCandidates) {
            if (!candidate) continue;
            try {
              const stat = await fs.stat(candidate);
              if (stat.isFile()) {
                cataloguePath = path.resolve(cwd, candidate);
                break;
              }
            } catch (_err) {
              // ignore missing candidate
            }
          }

          const componentsCandidates = [];
          const explicitComponents = resolveString(state.componentsRoot);
          if (explicitComponents) componentsCandidates.push(explicitComponents);
          const envComponents = resolveString(process.env.LCOD_COMPONENTS_PATH);
          if (envComponents) componentsCandidates.push(envComponents);
          componentsCandidates.push(path.join(projectRoot, '..', 'lcod-components'));
          componentsCandidates.push(path.join(projectRoot, '..', '..', 'lcod-components'));

          let componentsRoot = null;
          let componentsRegistryPath = null;
          for (const candidate of componentsCandidates) {
            if (!candidate) continue;
            const jsonlPath = path.join(candidate, 'registry', 'components.std.jsonl');
            const jsonPath = path.join(candidate, 'registry', 'components.std.json');
            let registryPath = null;
            try {
              const stat = await fs.stat(jsonlPath);
              if (stat.isFile()) {
                registryPath = jsonlPath;
              }
            } catch (_err) {
              // ignore
            }
            if (!registryPath) {
              try {
                const stat = await fs.stat(jsonPath);
                if (stat.isFile()) {
                  registryPath = jsonPath;
                }
              } catch (_err) {
                // ignore
              }
            }
            if (registryPath) {
              componentsRoot = path.resolve(cwd, candidate);
              componentsRegistryPath = path.resolve(cwd, registryPath);
              break;
            }
          }

          const specCandidates = [];
          const envSpec = resolveString(process.env.SPEC_REPO_PATH);
          if (envSpec) specCandidates.push(envSpec);
          const envHome = resolveString(process.env.LCOD_HOME);
          if (envHome) specCandidates.push(envHome);
          specCandidates.push(path.join(projectRoot, '..', 'lcod-spec'));
          specCandidates.push(path.join(projectRoot, '..', '..', 'lcod-spec'));

          let specRoot = null;
          for (const candidate of specCandidates) {
            if (!candidate) continue;
            try {
              const absolute = path.resolve(cwd, candidate);
              const stat = await fs.stat(absolute);
              if (!stat.isDirectory()) continue;
              const toolingDir = path.join(absolute, 'tooling');
              try {
                const toolingStat = await fs.stat(toolingDir);
                if (toolingStat.isDirectory()) {
                  specRoot = absolute;
                  break;
                }
              } catch (_err) {
                // ignore missing tooling directory
              }
            } catch (_err) {
              // ignore missing candidate
            }
          }

          const resolverCandidates = [];
          const envResolver = resolveString(process.env.LCOD_RESOLVER_PATH);
          if (envResolver) resolverCandidates.push(envResolver);
          if (specRoot) resolverCandidates.push(path.join(specRoot, 'resolver'));
          resolverCandidates.push(path.join(projectRoot, '..', 'lcod-resolver'));
          resolverCandidates.push(path.join(projectRoot, '..', '..', 'lcod-resolver'));

          let resolverRoot = null;
          for (const candidate of resolverCandidates) {
            if (!candidate) continue;
            try {
              const absolute = path.resolve(cwd, candidate);
              const stat = await fs.stat(absolute);
              if (!stat.isDirectory()) continue;
              const componentsDir = path.join(absolute, 'packages', 'resolver', 'components');
              try {
                const compStat = await fs.stat(componentsDir);
                if (compStat.isDirectory()) {
                  resolverRoot = absolute;
                  break;
                }
              } catch (_err) {
                // ignore missing components dir
              }
            } catch (_err) {
              // ignore candidate
            }
          }

          return {
            cwd,
            projectRoot,
            refererPath: refererPath ? path.resolve(cwd, refererPath) : null,
            projectCacheDir: path.resolve(projectRoot, projectCacheInput),
            userCacheDir: path.resolve(homeDir, userCacheInput),
            cataloguePath,
            componentsRoot,
            componentsRegistryPath,
            specRoot,
            resolverRoot
          };
        }
      input:
        refererPath: $.pathOptions.refererPath
        projectPath: $.pathOptions.projectPath
        projectCacheDir: $.cacheOptions.projectCacheDir
        userCacheDir: $.cacheOptions.userCacheDir
        cataloguePath: $.pathOptions.cataloguePath
        componentsRoot: $.pathOptions.componentsRoot
    out:
      resolvedPaths: resolvedPaths
  - call: lcod://tooling/script@1
    in:
      source: |
        async ({ state }) => {
          const fs = await import('node:fs/promises');
          const path = await import('node:path');
          const warnings = [];

          if (!state.componentsRegistryPath) {
            return { found: false, warnings };
          }

          try {
            const registryPath = state.componentsRegistryPath;
            const extension = path.extname(registryPath || '').toLowerCase();
            const text = await fs.readFile(registryPath, 'utf-8');

            let entries = [];
            if (extension === '.jsonl') {
              const lines = text
                .split(/\r?\n/)
                .map((line) => line.trim())
                .filter((line) => line.length > 0);
              if (lines.length === 0) {
                warnings.push(`Local registry ${registryPath} is empty`);
              } else {
                let startIndex = 0;
                try {
                  JSON.parse(lines[0]);
                  startIndex = 1;
                } catch (_err) {
                  // header missing or invalid, treat all lines as entries
                  startIndex = 0;
                }
                for (let i = startIndex; i < lines.length; i += 1) {
                  const raw = lines[i];
                  try {
                    const parsed = JSON.parse(raw);
                    entries.push(parsed);
                  } catch (err) {
                    warnings.push(`Failed to parse JSONL entry at ${registryPath}:${i + 1}: ${err.message || err}`);
                  }
                }
              }
            } else {
              const parsed = JSON.parse(text);
              if (Array.isArray(parsed)) {
                entries = parsed;
              } else {
                warnings.push(`Local registry ${registryPath} is not an array`);
              }
            }

            for (const entry of entries) {
              if (!entry || typeof entry.id !== 'string') continue;
              if (entry.id !== state.componentId) continue;
              const composeRel = typeof entry.compose === 'string'
                ? entry.compose
                : typeof entry.composePath === 'string'
                  ? entry.composePath
                  : null;
              if (!composeRel) {
                warnings.push(`Entry ${entry.id} missing compose path in ${registryPath}`);
                continue;
              }
              const composePath = path.resolve(state.componentsRoot, composeRel);
              return {
                found: true,
                result: {
                  id: entry.id,
                  composePath,
                  repoRoot: state.componentsRoot
                },
                warnings
              };
            }

            warnings.push(`Component ${state.componentId} not found in local registry ${registryPath}`);
          } catch (err) {
            warnings.push(`Failed to read local registry at ${state.componentsRegistryPath}: ${err.message || err}`);
          }

          return { found: false, warnings };
        }
      input:
        componentId: $.componentId
        componentsRoot: $.resolvedPaths.componentsRoot
        componentsRegistryPath: $.resolvedPaths.componentsRegistryPath
    out:
      localFound: found
      localResult: result
      localWarnings: warnings
  - call: lcod://flow/if@1
    in:
      cond: $.localFound
    out:
      finalFound: finalFound
      finalResult: finalResult
      finalWarnings: finalWarnings
    slots:
      then:
        - call: lcod://tooling/value/default_array@0.1.0
          in:
            value: $.localWarnings
          out:
            localWarningsNormalized: resolved
        - call: lcod://impl/set@1
          in:
            finalFound: true
            finalResult: $.localResult
            finalWarnings: $.localWarningsNormalized
          out:
            finalFound: finalFound
            finalResult: finalResult
            finalWarnings: finalWarnings
      else:
        - call: lcod://tooling/script@1
          in:
            source: |
              async ({ state }) => {
                const path = await import('node:path');
                const fs = await import('node:fs/promises');

                const normalize = (value) => (typeof value === 'string' && value.length ? value : null);
                const warnings = [];

                const componentId = normalize(state.componentId);
                if (!componentId || !componentId.startsWith('lcod://')) {
                  return { found: false, warnings };
                }

                const [idBody] = componentId.slice('lcod://'.length).split('@');
                if (!idBody) {
                  return { found: false, warnings };
                }
                const parts = idBody.split('/').filter(Boolean);
                if (parts.length === 0) {
                  return { found: false, warnings };
                }

                const exists = async (candidate) => {
                  try {
                    const stat = await fs.stat(candidate);
                    return stat.isFile();
                  } catch (_err) {
                    return false;
                  }
                };

                const candidates = [];
                if (normalize(state.specRoot)) {
                  candidates.push({
                    composePath: path.join(normalize(state.specRoot), ...parts, 'compose.yaml'),
                    repoRoot: normalize(state.specRoot)
                  });
                }
                if (normalize(state.resolverRoot) && parts[0] === 'resolver') {
                  const resolverParts = parts.slice(1);
                  candidates.push({
                    composePath: path.join(
                      normalize(state.resolverRoot),
                      'packages',
                      'resolver',
                      'components',
                      ...resolverParts,
                      'compose.yaml'
                    ),
                    repoRoot: normalize(state.resolverRoot)
                  });
                }

                for (const candidate of candidates) {
                  if (await exists(candidate.composePath)) {
                    return {
                      found: true,
                      warnings,
                      result: {
                        id: componentId,
                        composePath: candidate.composePath,
                        repoRoot: candidate.repoRoot
                      }
                    };
                  }
                }

                return { found: false, warnings };
              }
            input:
              componentId: $.componentId
              specRoot: $.resolvedPaths.specRoot
              resolverRoot: $.resolvedPaths.resolverRoot
          out:
            specLookupFound: specLookupFound
            specLookupResult: specLookupResult
            specLookupWarningsRaw: specLookupWarningsRaw
        - call: lcod://tooling/value/default_array@0.1.0
          in:
            value: $.specLookupWarningsRaw
          out:
            specLookupWarnings: specLookupWarnings
        - call: lcod://flow/if@1
          in:
            cond: $.specLookupFound
          out:
            finalResult: finalResult
            finalFound: finalFound
            finalWarnings: finalWarnings
          slots:
            then:
              - call: lcod://impl/set@1
                in:
                  finalFound: true
                  finalResult: $.specLookupResult
                  finalWarnings: $.specLookupWarnings
                out:
                  finalFound: finalFound
                  finalResult: finalResult
                  finalWarnings: finalWarnings
            else:
              - call: lcod://tooling/script@1
                in:
                  source: |
                    async ({ state }) => {
                      const ensureArray = (value) => (Array.isArray(value) ? value.filter((item) => item && typeof item === 'object') : []);
                      const sources = [];

                      if (state.cataloguePath) {
                        sources.push({
                          id: 'lcod-local',
                          entrypoint: { type: 'file', path: state.cataloguePath }
                        });
                      }

                      sources.push({
                        id: 'lcod-official',
                        entrypoint: {
                          type: 'https',
                          url: 'https://raw.githubusercontent.com/lcod-team/lcod-registry/main/catalogues.jsonl'
                        }
                      });

                      const extras = ensureArray(state.extraSources);
                      for (const entry of extras) {
                        try {
                          sources.push(JSON.parse(JSON.stringify(entry)));
                        } catch (_err) {
                          sources.push(entry);
                        }
                      }

                      return { sources };
                    }
                  input:
                    cataloguePath: $.resolvedPaths.cataloguePath
                    extraSources: $.extraRegistrySources
                out:
                  generatedSources: sources
              - call: lcod://impl/set@1
                in:
                  sourcesSpec:
                    schema: "lcod-resolver/sources@1"
                    sources: $.generatedSources
                out:
                  sourcesSpec: sourcesSpec
              - call: lcod://tooling/registry_sources/resolve@0.1.0
                in:
                  projectPath: $.resolvedPaths.projectRoot
                  cacheDir: $.resolvedPaths.projectCacheDir
                  sourcesPath: $.pathOptions.sourcesPath
                  defaultSourcesSpec: $.sourcesSpec
                  cwd: $.resolvedPaths.cwd
                out:
                  registrySources: registrySources
                  warnings: resolveWarnings
              - call: lcod://tooling/registry/index@0.1.0
                in:
                  sources: $.registrySources
                out:
                  registryEntries: registryEntries
                  registryPackages: registryPackages
                  registryRegistries: registryRegistries
                  indexWarnings: indexWarnings
              - call: lcod://tooling/value/default_array@0.1.0
                in:
                  value: $.registryEntries
                out:
                  registryEntriesList: resolved
              - call: lcod://tooling/value/is_string_nonempty@0.1.0
                in:
                  value: $.componentId
                out:
                  componentIdValid: componentIdValid
              - call: lcod://flow/foreach@1
                in:
                  list: $.registryEntriesList
                  collectPath: $.matches
                out:
                  matches: results
                slots:
                  body:
                    - call: lcod://tooling/value/is_object@0.1.0
                      in:
                        value: $slot.item
                      out:
                        entryIsObject: ok
                    - call: lcod://flow/if@1
                      in:
                        cond: $.entryIsObject
                      out:
                        match: match
                      slots:
                        then:
                          - call: lcod://tooling/value/is_string_nonempty@0.1.0
                            in:
                              value: $slot.item.id
                            out:
                              entryHasId: ok
                          - call: lcod://tooling/value/is_object@0.1.0
                            in:
                              value: $slot.item.compose
                            out:
                              composeIsObject: ok
                          - call: lcod://tooling/script@1
                            in:
                              source: |
                                async ({ state }) => ({ idsMatch: state.entryId === state.componentId })
                              input:
                                entryId: $slot.item.id
                                componentId: $.componentId
                            out:
                              idsMatch: idsMatch
                          - call: lcod://flow/if@1
                            in:
                              cond: $.componentIdValid
                            out:
                              match: match
                            slots:
                              then:
                                - call: lcod://flow/if@1
                                  in:
                                    cond: $.entryHasId
                                  out:
                                    match: match
                                  slots:
                                    then:
                                      - call: lcod://flow/if@1
                                        in:
                                          cond: $.idsMatch
                                        out:
                                          match: match
                                        slots:
                                          then:
                                            - call: lcod://flow/if@1
                                              in:
                                                cond: $.composeIsObject
                                              out:
                                                match: match
                                              slots:
                                                then:
                                                  - call: lcod://impl/set@1
                                                    in:
                                                      match: $slot.item
                                                    out:
                                                      match: match
                                                else:
                                                  - call: lcod://impl/set@1
                                                    in:
                                                      match: null
                                                    out:
                                                      match: match
                                          else:
                                            - call: lcod://impl/set@1
                                              in:
                                                match: null
                                              out:
                                                match: match
                                    else:
                                      - call: lcod://impl/set@1
                                        in:
                                          match: null
                                        out:
                                          match: match
                              else:
                                - call: lcod://impl/set@1
                                  in:
                                    match: null
                                  out:
                                    match: match
                        else:
                          - call: lcod://impl/set@1
                            in:
                              match: null
                            out:
                              match: match
              - call: lcod://tooling/value/default_array@0.1.0
                in:
                  value: $.matches
                out:
                  matches: matches
              - call: lcod://tooling/value/is_object@0.1.0
                in:
                  value: $.matches[0]
                out:
                  firstMatchIsObject: ok
              - call: lcod://tooling/value/default_array@0.1.0
                in:
                  value: $.resolveWarnings
                out:
                  resolveWarningsArray: resolved
              - call: lcod://tooling/value/default_array@0.1.0
                in:
                  value: $.indexWarnings
                out:
                  indexWarningsArray: resolved
              - call: lcod://tooling/array/append@0.1.0
                in:
                  items: $.resolveWarningsArray
                  values: $.indexWarningsArray
                out:
                  aggregatedWarnings: items
              - call: lcod://tooling/array/append@0.1.0
                in:
                  items: $.specLookupWarnings
                  values: $.aggregatedWarnings
                out:
                  aggregatedWarningsWithSpec: items
              - call: lcod://flow/if@1
                in:
                  cond: $.firstMatchIsObject
                out:
                  finalResult: finalResult
                  finalFound: finalFound
                  finalWarnings: finalWarnings
                slots:
                  then:
                    - call: lcod://impl/set@1
                      in:
                        finalFound: true
                        finalResult: $.matches[0]
                        finalWarnings: $.aggregatedWarningsWithSpec
                      out:
                        finalFound: finalFound
                        finalResult: finalResult
                        finalWarnings: finalWarnings
                  else:
                    - call: lcod://impl/set@1
                      in:
                        finalFound: false
                        finalResult: null
                        finalWarnings: $.aggregatedWarningsWithSpec
                      out:
                        finalFound: finalFound
                        finalResult: finalResult
                        finalWarnings: finalWarnings
  - call: lcod://tooling/value/default_array@0.1.0
    in:
      value: $.finalWarnings
    out:
      finalWarnings: finalWarnings
  - call: lcod://impl/set@1
    in:
      found: $.finalFound
      result: $.finalResult
      warnings: $.finalWarnings
    out:
      found: found
      result: result
      warnings: warnings
